name: Qemu-Vortax V 2.1

on:
  workflow_dispatch:
    inputs:
      system_choice:
        description: 'Choose a ready system (bazite, bliss, centos_qcow2, cutefish, debian_qcow2, deepin, garuda_mokka, kali, manjaro, mint, pear, pop_os, ubuntu, win7)'
        required: false
        default: ''
      boot_mode:
        description: 'Choose boot type: iso or qcow2'
        required: true
        default: 'qcow2'
      source_url:
        description: 'Custom source URL (optional)'
        required: false
        default: ''
      vm_name:
        description: 'Name of the system/disk'
        required: true
        default: 'ME2008'
      runtime:
        description: 'Runtime duration in minutes (default 335)'
        required: false
        default: '335'
      connection_method:
        description: 'Choose connection method: tailscale or ngrok'
        required: true
        default: 'tailscale'
      connection_program:
        description: 'Select program (RDP, VNC, NoMachine)'
        required: true
        default: 'VNC'
      bios_mode:
        description: 'Choose firmware mode: UEFI or BIOS (default BIOS)'
        required: true
        default: 'BIOS'
      vnc_password:
        description: 'VNC password'
        required: true
        default: 'runner'
      upload_qcow2:
        description: 'Upload QCOW2 file to Mega: yes or no'
        required: true
        default: 'yes'

permissions:
  contents: read

jobs:
  setup-and-run:
    runs-on: ubuntu-latest
    timeout-minutes: 360
    outputs:
      connection_type: ${{ steps.set-outputs.outputs.CONNECTION_TYPE }}
      connection_ip: ${{ steps.set-outputs.outputs.CONNECTION_IP }}
    env:
      USERNAME: runner
      PASSWORD: runner
      RUNNER_TEMP: /mnt/tmp
      ACTIONS_RUNNER_CACHE: /mnt/cache
      DEFAULT_DISK_GB: '60'
      DEFAULT_VCPUS: '2'

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Prepare environment & validate inputs
        id: validate
        run: |
          set -euo pipefail
          echo "Creating temp dirs..."
          sudo mkdir -p "${RUNNER_TEMP}" "${ACTIONS_RUNNER_CACHE}"
          sudo chmod 1777 "${RUNNER_TEMP}" "${ACTIONS_RUNNER_CACHE}"

          # Basic validation for secrets when needed
          METHOD="${{ github.event.inputs.connection_method }}"
          if [ "$METHOD" = "tailscale" ] && [ -z "${{ secrets.TAILSCALE_AUTHKEY }}" ]; then
            echo "::error::TAILSCALE_AUTHKEY is required for tailscale method"
            exit 1
          fi
          if [ "$METHOD" = "ngrok" ] && [ -z "${{ secrets.NGROK_AUTH }}" ]; then
            echo "::error::NGROK_AUTH is required for ngrok method"
            exit 1
          fi

          # Export some variables for later
          echo "VM_NAME=${{ github.event.inputs.vm_name }}" >> $GITHUB_ENV
          echo "BOOT_MODE=${{ github.event.inputs.boot_mode }}" >> $GITHUB_ENV
          echo "CHOICE=${{ github.event.inputs.system_choice }}" >> $GITHUB_ENV
          echo "SRC_URL=${{ github.event.inputs.source_url }}" >> $GITHUB_ENV
          echo "VNC_PASS=${{ github.event.inputs.vnc_password }}" >> $GITHUB_ENV
          echo "UPLOAD_QCOW2=${{ github.event.inputs.upload_qcow2 }}" >> $GITHUB_ENV
          echo "CONN_METHOD=${{ github.event.inputs.connection_method }}" >> $GITHUB_ENV
          echo "RUNTIME_MIN=${{ github.event.inputs.runtime }}" >> $GITHUB_ENV
          echo "BIOS_MODE=${{ github.event.inputs.bios_mode }}" >> $GITHUB_ENV

      - name: Install minimal tools (retry-friendly download + qemu)
        run: |
          set -euo pipefail
          sudo apt-get update -y -qq
          sudo apt-get install -y -qq wget curl unzip p7zip-full qemu-system-x86 python3-pip jq
          pip3 install --user internetarchive rich requests || true
          # safer path for local python packages
          export PATH=$HOME/.local/bin:$PATH
          echo "Tools installed."

      - name: Setup Connection (Tailscale or Ngrok)
        id: set-outputs
        run: |
          set -euo pipefail
          METHOD="${CONN_METHOD}"
          CONNECTION_IP=""
          CONNECTION_TYPE=""
          if [ "$METHOD" = "tailscale" ]; then
            echo "Installing Tailscale via apt (stable)..."
            curl -fsSL https://pkgs.tailscale.com/stable/ubuntu/focal.gpg | sudo apt-key add -
            curl -fsSL https://pkgs.tailscale.com/stable/ubuntu/focal.list | sudo tee /etc/apt/sources.list.d/tailscale.list
            sudo apt-get update -y -qq
            sudo apt-get install -y tailscale
            sudo tailscale up --authkey "${{ secrets.TAILSCALE_AUTHKEY }}" --hostname "gh-xfce-vm-${{ github.run_id }}" --accept-routes --accept-dns=false || true
            # small sleep to allow IP to register
            sleep 5
            CONNECTION_IP=$(sudo tailscale ip -4 | head -n1 || true)
            CONNECTION_TYPE="Tailscale"
          elif [ "$METHOD" = "ngrok" ]; then
            echo "Installing ngrok..."
            wget -q -O ngrok.zip "https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-linux-amd64.zip"
            unzip -q ngrok.zip
            sudo mv ngrok /usr/local/bin/
            ngrok config add-authtoken "${{ secrets.NGROK_AUTH }}" || true
            CONNECTION_TYPE="Ngrok"
          else
            echo "::error::Unknown connection method: $METHOD"
            exit 1
          fi

          echo "CONNECTION_IP=${CONNECTION_IP}" >> $GITHUB_OUTPUT
          echo "CONNECTION_TYPE=${CONNECTION_TYPE}" >> $GITHUB_OUTPUT

      - name: Prepare virt/ovmf + helper scripts
        run: |
          set -euo pipefail
          mkdir -p $RUNNER_TEMP/qemu-ovmf
          cd $RUNNER_TEMP/qemu-ovmf
          # try to download OVMF from a reliable mirror; if fails, continue but warn
          for url in \
            "https://gitlab.com/MR.English2008/qemu-pre-build-ovfm.fd-files/-/raw/main/OVMF_CODE.fd" \
            "https://releases.pagure.org/edk2/OVMF_CODE.fd" ; do
            echo "Trying $url"
            if wget -q -O OVMF_CODE.fd "$url"; then
              echo "Downloaded OVMF_CODE.fd"
              break
            fi
          done
          # Vvars file (writable)
          if [ ! -f OVMF_VARS.fd ]; then
            cp OVMF_CODE.fd OVMF_VARS.fd || true
          fi
          echo "OVMF prepared at $RUNNER_TEMP/qemu-ovmf"

      - name: Determine final source URL (choice mapping + fallback)
        id: determine_url
        run: |
          set -euo pipefail
          CHOICE="${CHOICE}"
          USER_URL="${SRC_URL}"
          BOOT="${BOOT_MODE}"

          declare -A ISO_URLS
          ISO_URLS["bazite"]="https://download.bazzite.gg/bazzite-stable-live.iso"
          ISO_URLS["bliss"]="https://dn720203.ca.archive.org/0/items/Bliss-v15.9-x86_64-OFFICIAL-gapps-20240114/Bliss-v15.9-x86_64-OFFICIAL-gapps-20240114.iso"
          ISO_URLS["cutefish"]="https://netix.dl.sourceforge.net/project/cutefish-ubuntu/ISO/Ubuntu/CutefishOS-22.04.0-YoYo-beta-amd64.iso"
          ISO_URLS["deepin"]="https://cdimage-cdn77.deepin.com/deepin-cd/25.0.1/amd64/deepin-desktop-community-25.0.1-amd64.iso"
          ISO_URLS["garuda_mokka"]="https://r2.garudalinux.org/iso/garuda/mokka/251002/garuda-mokka-linux-zen-251002.iso"
          ISO_URLS["kali"]="https://kali.download/base-images/kali-2025.3/kali-linux-2025.3-live-amd64.iso"
          ISO_URLS["manjaro"]="https://download.manjaro.org/gnome/25.0.10/manjaro-gnome-25.0.10-251013-linux612.iso"
          ISO_URLS["mint"]="https://pub.linuxmint.io/stable/22.2/linuxmint-22.2-cinnamon-64bit.iso"
          ISO_URLS["pear"]="https://www.mediafire.com/file/7ztcyqd2ggiv58p/pearOS-NiceC0re-2025.11-x86_64.iso"
          ISO_URLS["pop_os"]="https://iso.pop-os.org/22.04/amd64/intel/58/pop-os_22.04_amd64_intel_58.iso"
          ISO_URLS["ubuntu"]="https://releases.ubuntu.com/25.10/ubuntu-25.10-desktop-amd64.iso"

          declare -A QCOW2_URLS
          QCOW2_URLS["centos_qcow2"]="https://cloud.centos.org/centos/10-stream/x86_64/images/CCentOS-Stream-GenericCloud-x86_64-10-latest.x86_64.qcow2"
          QCOW2_URLS["debian_qcow2"]="https://chuangtzu.ftp.acc.umu.se/images/cloud/bookworm/20251006-2257/debian-12-generic-amd64-20251006-2257.qcow2"
          QCOW2_URLS["win7"]="https://www.mediafire.com/file/py5c5n111ns72x0/win7.7z"

          FINAL_URL="${USER_URL}"
          if [ -z "${FINAL_URL}" ] && [ -n "${CHOICE}" ]; then
            if [ "${BOOT}" = "iso" ]; then
              FINAL_URL="${ISO_URLS[$CHOICE]:-}"
            else
              FINAL_URL="${QCOW2_URLS[$CHOICE]:-}"
            fi
          fi
          if [ -z "${FINAL_URL}" ]; then
            echo "No URL from choice or custom source provided. Defaulting to Bliss ISO."
            FINAL_URL="${ISO_URLS["bliss"]}"
          fi
          echo "FINAL_SOURCE_URL=${FINAL_URL}" >> $GITHUB_ENV
          echo "Determined source: ${FINAL_URL}"

      - name: Download and prepare source (robust)
        run: |
          set -euo pipefail
          VM="${VM_NAME}"
          SRC="${FINAL_SOURCE_URL}"
          TMP_DIR="${RUNNER_TEMP}/vm_prepare"
          mkdir -p "${TMP_DIR}"
          cd "${TMP_DIR}"

          # helper: retry wget
          retry_wget() {
            local url="$1"; local out="$2"
            for i in 1 2 3; do
              if wget -q --user-agent="Mozilla/5.0" --trust-server-names --content-disposition -O "$out" "$url"; then
                return 0
              fi
              sleep $((i * 2))
            done
            return 1
          }

          echo "Downloading: $SRC"
          FILE_PATH="${TMP_DIR}/source_file"
          if echo "$SRC" | grep -q "archive.org"; then
            # use internetarchive if installed
            ITEM=$(basename "$(dirname "$SRC")")
            FILE=$(basename "$SRC")
            ia download "$ITEM" "$FILE" || true
            FOUND=$(find . -type f -name "$FILE" | head -n1 || true)
            if [ -n "$FOUND" ]; then
              mv "$FOUND" "$FILE_PATH"
            fi
          elif echo "$SRC" | grep -E "mediafire|mega" >/dev/null 2>&1; then
            # use badown or wget fallback
            if [ -d "$HOME/badown" ]; then
              cd $HOME/badown
              sudo ./badown "$SRC" || true
              DOWNLOADED=$(ls -t | head -n1)
              mv "$DOWNLOADED" "$FILE_PATH" || true
            else
              retry_wget "$SRC" "$FILE_PATH" || true
            fi
          else
            retry_wget "$SRC" "$FILE_PATH" || true
          fi

          if [ ! -f "$FILE_PATH" ]; then
            echo "::error::Download failed or no file produced from the source URL."
            ls -la
            exit 1
          fi

          MIME=$(file -b --mime-type "$FILE_PATH")
          echo "Detected mime: $MIME"

          MNT_PATH="/mnt"
          DISK_GB="${DEFAULT_DISK_GB}"

          if [[ "$MIME" == *iso* ]] || [[ "${BOOT_MODE}" == "iso" ]]; then
            mv "$FILE_PATH" "$HOME/${VM}.iso"
            qemu-img create -f qcow2 "${MNT_PATH}/${VM}.qcow2" "${DISK_GB}G" || true
          else
            # archives or qcow2 images
            # try to unpack common archival formats
            case "$MIME" in
              application/x-7z-compressed|application/zip|application/x-rar)
                mkdir -p unpack
                if [[ "$MIME" == *7z* ]]; then 7z x "$FILE_PATH" -ounpack || true; fi
                if [[ "$MIME" == *zip* ]]; then unzip -q "$FILE_PATH" -d unpack || true; fi
                if [[ "$MIME" == *rar* ]]; then unrar x -inul "$FILE_PATH" unpack || true; fi
                FINDIMG=$(find unpack -type f -iname "*.qcow2" -o -iname "*.img" -o -iname "*.iso" | head -n1 || true)
                if [ -n "$FINDIMG" ]; then
                  if [[ "$FINDIMG" == *.iso ]]; then mv "$FINDIMG" "$HOME/${VM}.iso"; qemu-img create -f qcow2 "${MNT_PATH}/${VM}.qcow2" "${DISK_GB}G" || true; else mv "$FINDIMG" "${MNT_PATH}/${VM}.qcow2"; fi
                else
                  echo "No usable image inside archive."
                  exit 1
                fi
                ;;
              application/x-qemu-disk|application/octet-stream)
                mv "$FILE_PATH" "${MNT_PATH}/${VM}.qcow2"
                ;;
              *)
                echo "Unhandled mime type: $MIME - trying to treat as qcow2"
                mv "$FILE_PATH" "${MNT_PATH}/${VM}.qcow2" || true
                ;;
            esac
          fi

      - name: Install and configure desktop services (XFCE, XRDP, NoMachine optional)
        run: |
          set -euo pipefail
          sudo apt-get update -y -qq
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y -qq xfce4 xfce4-goodies xorg dbus-x11 xrdp tigervnc-viewer wmctrl genisoimage || true
          # configure user session files (if user exists)
          sudo useradd -m -s /bin/bash ${USERNAME} || true
          echo "${USERNAME}:${PASSWORD}" | sudo chpasswd
          echo "${USERNAME} ALL=(ALL) NOPASSWD:ALL" | sudo tee /etc/sudoers.d/${USERNAME} >/dev/null
          echo "startxfce4" | sudo tee /home/${USERNAME}/.xsession >/dev/null
          sudo chown ${USERNAME}:${USERNAME} /home/${USERNAME}/.xsession || true
          sudo systemctl enable --now xrdp || true

      - name: Start QEMU (background) and save PID + logs
        run: |
          set -euo pipefail
          VM="${VM_NAME}"
          MNT_PATH="/mnt"
          ISO_PATH="$HOME/${VM}.iso"
          DISK_PATH="${MNT_PATH}/${VM}.qcow2"
          RAM_GB="${{ env.RAM:-14 }}"
          VCPUS="${{ env.DEFAULT_VCPUS }}"
          OVMF_DIR="${RUNNER_TEMP}/qemu-ovmf"
          CODE_PATH="${OVMF_DIR}/OVMF_CODE.fd"
          VARS_PATH="${OVMF_DIR}/OVMF_VARS.fd"
          LOG_DIR="${RUNNER_TEMP}/qemu-logs"
          mkdir -p "${LOG_DIR}"
          QEMU_LOG="${LOG_DIR}/${VM}-qemu.log"

          # create vnc password file securely
          mkdir -p /tmp/qemu_pw
          echo "${VNC_PASS}" > /tmp/qemu_pw/passwd
          # create qemu monitor socket file
          MONFILE="${RUNNER_TEMP}/${VM}.monitor"

          if [ "${BIOS_MODE}" = "UEFI" ]; then
            if [ -f "$ISO_PATH" ]; then
              # boot from iso
              nohup sudo qemu-system-x86_64 \
                -enable-kvm -cpu host -smp ${VCPUS} -m ${RAM_GB}G \
                -boot d -cdrom "$ISO_PATH" \
                -drive if=none,id=hd0,file="$DISK_PATH",format=qcow2 -device virtio-blk-pci,drive=hd0 \
                -drive if=pflash,format=raw,readonly=on,file="$CODE_PATH" -drive if=pflash,format=raw,file="$VARS_PATH" \
                -vnc :0,password=on -monitor unix:${MONFILE},server,nowait -display none \
                -netdev user,id=net0 -device e1000,netdev=net0 \
                -device usb-ehci -device usb-tablet \
                -drive file=/mnt/virtio-win.iso,media=cdrom,if=none,id=cd1 -device ide-cd,bus=ide.1,drive=cd1 \
                -name "$VM" >"${QEMU_LOG}" 2>&1 &
            else
              nohup sudo qemu-system-x86_64 \
                -enable-kvm -cpu host -smp ${VCPUS} -m ${RAM_GB}G \
                -hda "$DISK_PATH" \
                -drive if=pflash,format=raw,readonly=on,file="$CODE_PATH" -drive if=pflash,format=raw,file="$VARS_PATH" \
                -vnc :0,password=on -monitor unix:${MONFILE},server,nowait -display none \
                -netdev user,id=net0 -device e1000,netdev=net0 \
                -device usb-ehci -device usb-tablet \
                -drive file=/mnt/virtio-win.iso,media=cdrom,if=none,id=cd1 -device ide-cd,bus=ide.1,drive=cd1 \
                -name "$VM" >"${QEMU_LOG}" 2>&1 &
            fi
          else
            # legacy BIOS flow
            if [ -f "$ISO_PATH" ]; then
              nohup sudo qemu-system-x86_64 \
                -enable-kvm -cpu host -smp ${VCPUS} -m ${RAM_GB}G \
                -boot d -cdrom "$ISO_PATH" -hda "$DISK_PATH" \
                -vnc :0,password=on -monitor unix:${MONFILE},server,nowait -display none \
                -netdev user,id=net0 -device e1000,netdev=net0 \
                -device usb-ehci -device usb-tablet \
                -drive file=/mnt/virtio-win.iso,media=cdrom,if=none,id=cd1 -device ide-cd,bus=ide.1,drive=cd1 \
                -name "$VM" >"${QEMU_LOG}" 2>&1 &
            else
              nohup sudo qemu-system-x86_64 \
                -enable-kvm -cpu host -smp ${VCPUS} -m ${RAM_GB}G \
                -hda "$DISK_PATH" \
                -vnc :0,password=on -monitor unix:${MONFILE},server,nowait -display none \
                -netdev user,id=net0 -device e1000,netdev=net0 \
                -device usb-ehci -device usb-tablet \
                -drive file=/mnt/virtio-win.iso,media=cdrom,if=none,id=cd1 -device ide-cd,bus=ide.1,drive=cd1 \
                -name "$VM" >"${QEMU_LOG}" 2>&1 &
            fi
          fi

          QEMU_PID=$!
          echo "QEMU PID: $QEMU_PID"
          echo $QEMU_PID > "${RUNNER_TEMP}/${VM}.pid"
          echo "QEMU log at: ${QEMU_LOG}"

          # wait for monitor socket to be available (simple readiness)
          COUNTER=0
          while [ $COUNTER -lt 30 ]; do
            if [ -e "${MONFILE}" ]; then
              echo "Monitor socket exists."
              break
            fi
            sleep 1
            COUNTER=$((COUNTER+1))
          done

      - name: Save artifacts: logs and qcow2 (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: qemu-artifacts
          path: |
            ${{ env.RUNNER_TEMP }}/qemu-logs
            /mnt/${{ github.event.inputs.vm_name }}.qcow2
            ${{ env.RUNNER_TEMP }}/${{ github.event.inputs.vm_name }}.pid

      - name: Optional: Upload QCOW2 to Mega (if requested)
        if: ${{ env.UPLOAD_QCOW2 == 'yes' }}
        run: |
          set -euo pipefail
          # This is a placeholder: user must supply a script/credentials to push to mega.
          echo "UPLOAD_QCOW2=yes - implement your Mega CLI upload here if desired"
          # Example: python3 /path/to/mega_gen_cli.py upload /mnt/${{ github.event.inputs.vm_name }}.qcow2

      - name: Final status
        if: always()
        run: |
          set -euo pipefail
          echo "Job finished. If QEMU still running, PID:"
          if [ -f "${RUNNER_TEMP}/${{ github.event.inputs.vm_name }}.pid" ]; then
            cat "${RUNNER_TEMP}/${{ github.event.inputs.vm_name }}.pid" || true
          fi
          # show top of qemu log for quick debug
          QLOG="${RUNNER_TEMP}/qemu-logs/${{ github.event.inputs.vm_name }}-qemu.log"
          if [ -f "$QLOG" ]; then
            echo "=== qemu log head ==="
            head -n 200 "$QLOG" || true
          fi
          
